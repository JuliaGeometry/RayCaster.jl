var documenterSearchIndex = {"docs":
[{"location":"index.html#RayCaster.jl","page":"Home","title":"RayCaster.jl","text":"","category":"section"},{"location":"index.html","page":"Home","title":"Home","text":"using RayCaster, GeometryBasics, LinearAlgebra\nusing WGLMakie, FileIO\n\nfunction LowSphere(radius, contact=Point3f(0); ntriangles=10)\n    return Tesselation(Sphere(contact .+ Point3f(0, 0, radius), radius), ntriangles)\nend\n\nntriangles = 10\ns1 = LowSphere(0.5f0, Point3f(-0.5, 0.0, 0); ntriangles)\ns2 = LowSphere(0.3f0, Point3f(1, 0.5, 0); ntriangles)\ns3 = LowSphere(0.3f0, Point3f(-0.5, 1, 0); ntriangles)\ns4 = LowSphere(0.4f0, Point3f(0, 1.0, 0); ntriangles)\nl = 0.5\nfloor = Rect3f(-l, -l, -0.01, 2l, 2l, 0.01)\ncat = load(Makie.assetpath(\"cat.obj\"))\nbvh = RayCaster.BVHAccel([s1, s2, s3, s4, cat]);\nworld_mesh = GeometryBasics.Mesh(bvh)\nf, ax, pl = Makie.mesh(world_mesh; color=:teal)\ncenter!(ax.scene)\nviewdir = normalize(ax.scene.camera.view_direction[])\n\n@time \"hitpoints\" hitpoints, centroid = RayCaster.get_centroid(bvh, viewdir)\n@time \"illum\" illum = RayCaster.get_illumination(bvh, viewdir)\n@time \"viewf_matrix\" viewf_matrix = RayCaster.view_factors(bvh, rays_per_triangle=1000)\nviewfacts = map(i-> Float32(sum(view(viewf_matrix, :, i))), 1:length(bvh.primitives))\nworld_mesh = GeometryBasics.Mesh(bvh)\nN = length(world_mesh.faces)\nareas = map(i-> area(world_mesh.position[world_mesh.faces[i]]), 1:N)\n# View factors\nf, ax, pl = mesh(world_mesh, color=:teal, figure=(; size=(800, 600)), axis=(; show_axis=false))\nper_face_vf = FaceView((viewfacts), [GLTriangleFace(i) for i in 1:N])\nviewfact_mesh = GeometryBasics.mesh(world_mesh, color=per_face_vf)\npl = Makie.mesh(f[1, 2],\n    viewfact_mesh, colormap=[:black, :red], axis=(; show_axis=false),\n    shading=false, highclip=:red, lowclip=:black, colorscale=sqrt,)\n\n# Centroid\ncax, pl = Makie.mesh(f[2, 1], world_mesh, color=(:blue, 0.5), axis=(; show_axis=false), transparency=true)\n\neyepos = cax.scene.camera.eyeposition[]\ndepth = map(x-> norm(x .- eyepos), hitpoints)\nmeshscatter!(cax, hitpoints, color=depth, colormap=[:gray, :black], markersize=0.01)\nmeshscatter!(cax, centroid, color=:red, markersize=0.05)\n\n# Illum\npf = FaceView(100f0 .* (illum ./ areas), [GLTriangleFace(i) for i in 1:N])\nillum_mesh = GeometryBasics.mesh(world_mesh, color=pf)\n\nMakie.mesh(f[2, 2], illum_mesh, colormap=[:black, :yellow], colorscale=sqrt, shading=false, axis=(; show_axis=false))\n\nLabel(f[0, 1], \"Scene ($(length(bvh.primitives)) triangles)\", tellwidth=false, fontsize=20)\nLabel(f[0, 2], \"Viewfactors\", tellwidth=false, fontsize=20)\nLabel(f[3, 1], \"Centroid\", tellwidth=false, fontsize=20)\nLabel(f[3, 2], \"Illumination\", tellwidth=false, fontsize=20)\n\nf","category":"page"},{"location":"index.html#Overview","page":"Home","title":"Overview","text":"","category":"section"},{"location":"index.html#Private-Functions","page":"Home","title":"Private Functions","text":"","category":"section"},{"location":"index.html#RayCaster.compute_differentials-Tuple{RayCaster.SurfaceInteraction, RayCaster.RayDifferentials}","page":"Home","title":"RayCaster.compute_differentials","text":"Compute partial derivatives needed for computing sampling rates for things like texture antialiasing.\n\n\n\n\n\n","category":"method"},{"location":"index.html#RayCaster.compute_scattering!","page":"Home","title":"RayCaster.compute_scattering!","text":"If an intersection was found, it is necessary to determine, how the surface's material scatters light. compute_scattering! method evaluates texture functions to determine surface properties and then initializing a representation of the BSDF at the point.\n\n\n\n\n\n","category":"function"},{"location":"index.html#RayCaster.cos_θ-Tuple{GeometryBasics.Vec{3, Float32}}","page":"Home","title":"RayCaster.cos_θ","text":"The shading coordinate system gives a frame for expressing directions in spherical coordinates (θ, ϕ). The angle θ is measured from the given direction to the z-axis and ϕ is the angle formed with the x-axis after projection of the direction onto xy-plane.\n\nSince normal is (0, 0, 1) → cos_θ = n · w = (0, 0, 1) ⋅ w = w.z.\n\n\n\n\n\n","category":"method"},{"location":"index.html#RayCaster.face_forward-Tuple{Any, Any}","page":"Home","title":"RayCaster.face_forward","text":"Flip normal n so that it lies in the same hemisphere as v.\n\n\n\n\n\n","category":"method"},{"location":"index.html#RayCaster.generate_ray_grid-Tuple{RayCaster.BVHAccel, GeometryBasics.Vec{3, Float32}, Int64}","page":"Home","title":"RayCaster.generate_ray_grid","text":"generate_ray_grid(bvh::BVHAccel, ray_direction::Vec3f, grid_size::Int)\n\nGenerate a grid of ray origins based on the BVH bounding box and a given ray direction.\n\n\n\n\n\n","category":"method"},{"location":"index.html#RayCaster.intersect!-Union{Tuple{P}, Tuple{RayCaster.BVHAccel{P}, RayCaster.AbstractRay}} where P","page":"Home","title":"RayCaster.intersect!","text":"intersect!(bvh::BVHAccel{P}, ray::AbstractRay) where {P}\n\nFind the closest intersection between a ray and the primitives stored in a BVH.\n\nReturns:\n\nhit_found: Boolean indicating if an intersection was found\nhit_primitive: The primitive that was hit (if any)\nbarycentric_coords: Barycentric coordinates of the hit point\n\n\n\n\n\n","category":"method"},{"location":"index.html#RayCaster.intersect_p-Tuple{RayCaster.BVHAccel, RayCaster.AbstractRay}","page":"Home","title":"RayCaster.intersect_p","text":"intersect_p(bvh::BVHAccel, ray::AbstractRay)\n\nTest if a ray intersects any primitive in the BVH (without finding the closest hit).\n\nReturns:\n\nhit_found: Boolean indicating if any intersection was found\n\n\n\n\n\n","category":"method"},{"location":"index.html#RayCaster.intersect_p-Tuple{RayCaster.Bounds3, RayCaster.AbstractRay, GeometryBasics.Vec{3, Float32}, GeometryBasics.Point3{UInt8}}","page":"Home","title":"RayCaster.intersect_p","text":"dirisnegative: 1 – false, 2 – true\n\n\n\n\n\n","category":"method"},{"location":"index.html#RayCaster.maximum_extent-Tuple{RayCaster.Bounds3}","page":"Home","title":"RayCaster.maximum_extent","text":"Return index of the longest axis. Useful for deciding which axis to subdivide, when building ray-tracing acceleration structures.\n\n1 - x, 2 - y, 3 - z.\n\n\n\n\n\n","category":"method"},{"location":"index.html#RayCaster.offset-Tuple{RayCaster.Bounds3, GeometryBasics.Point{3, Float32}}","page":"Home","title":"RayCaster.offset","text":"Get offset of a point from the minimum point of the bounds.\n\n\n\n\n\n","category":"method"},{"location":"index.html#RayCaster.partial_derivatives-Tuple{RayCaster.Sphere, GeometryBasics.Point{3, Float32}, Float32, Float32, Float32}","page":"Home","title":"RayCaster.partial_derivatives","text":"Compute partial derivatives of intersection point in parametric form.\n\n\n\n\n\n","category":"method"},{"location":"index.html#RayCaster.reflect-Tuple{GeometryBasics.Vec{3, Float32}, GeometryBasics.Vec{3, Float32}}","page":"Home","title":"RayCaster.reflect","text":"Reflect wo about n.\n\n\n\n\n\n","category":"method"},{"location":"index.html#RayCaster.test_clipping-Tuple{RayCaster.Sphere, GeometryBasics.Point{3, Float32}, Float32}","page":"Home","title":"RayCaster.test_clipping","text":"Test if hit point exceeds clipping parameters of the sphere.\n\n\n\n\n\n","category":"method"},{"location":"index.html#RayCaster.traverse_bvh-Union{Tuple{F}, Tuple{P}, Tuple{F, RayCaster.BVHAccel{P}, RayCaster.AbstractRay}} where {P, F<:Function}","page":"Home","title":"RayCaster.traverse_bvh","text":"_traverse_bvh(bvh::BVHAccel{P}, ray::AbstractRay, hit_callback::F) where {P, F<:Function}\n\nInternal function that traverses the BVH to find ray-primitive intersections. Uses a callback pattern to handle different intersection behaviors.\n\nArguments:\n\nbvh: The BVH acceleration structure\nray: The ray to test for intersections\nhit_callback: Function called when primitive is tested. Signature:  hitcallback(primitive, ray) -> (continuetraversal::Bool, ray::AbstractRay, results::Any)\n\nReturns:\n\nThe final result from the hit_callback\n\n\n\n\n\n","category":"method"}]
}
